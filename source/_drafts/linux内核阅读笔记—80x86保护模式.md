### 基本内容

1. 80x86基本知识
2. 保护模式内存管理
3. 各种保护措施
4. 中断和异常处理
5. 任务管理
6. 保护模式编程初始化
7. 一个简单的多任务内核例子

### 80x86 寄存器和系统指令

1. 标志寄存器EFLAGS。
    1. 任务切换
    2. 中断处理
    3. 指令跟踪
    4. 权限访问
2. 系统寄存器
2-1. 内存管理系统寄存器。指定分段内存管理所使用**系统表**的基地址。处理器为这些寄存器的加载和保存提供了特定的指令。
    1. GDTR。全局描述符表寄存器。用于存放全局描述符表的32位线性基地址和16位表长度。指令LGDT和SGDT分别用于加载和保存寄存器的内容。在处理器刚加电或处理器复位后，基地址默认为0，表长度默认为0XFFFF。
在保护模式初始化过程中必须给GDTR加载一个新值。
    2. IDTR。中断描述符表寄存器。用于存放中断描述符表IDT的32位线性基地址和16位表长度。指令LIDT和SIDT分别用于加载和保存寄存器的内容。其他同上。
    3. LDTR。局部描述符表寄存器。用于存放局部描述符表LDT的32位线性基地址和16位段限长和描述符属性值。LLDT和SLDT用于加载和保存段描述符部分。
    4. TR。任务寄存器用于存放当前任务TSS段的相关地址信息。
    段基址寄存器。前三个用于寻找存放描述符表的段。TR用于寻找一个特殊的任务状态段(TSS)。TSS包含着当前执行任务的重要信息。
2-1. 控制寄存器。
    1. CR0。
    2. CR1。
    3. CR2。
    4. CR3。
3. 系统指令。LGDT，SGDT等

### 保护模式内存管理

1. 内存寻址。
    1. 内存是有序字节数组。每个字节有唯一地址。
    2. 对于一个32位地址总线的系统，总共有4GB的地址空间。
    3. 对于80x86cpu，一条指令主要由操作码和操作数组成。操作数可以在内存，也可以在寄存器。
    4. 段寻址技术。将地址空间分为一个或者多个段的线性区域。段地址由16位的段选择符指定。段内偏移地址使用32位的值来指定。因此段内的地址大小为4G。
    5. 程序中的16位的段和32位的偏移地址，组成了48位长度的逻辑地址。
1-1. 80x86为段部分提供了6个存放段选择符的寄存器：
    1. CS。代码段寄存器。
    2. DS。通用段寄存器。
    3. ES。通用段寄存器。
    4. SS。堆栈段寄存器。由ss寄存器寻址的段成为当前堆栈段，ESP指定了栈顶。
    5. FS。通用段寄存器。
    6. GS。通用段寄存器。
2. 地址变换。任何完整内存管理系统都包括了两个关键部分：保护和地址变换。
    1. 保护。防止一个任务访问另一个任务的内存区域。
    2. 地址变换。使得内存分配变得灵活。使得特定的物理内存永远不被使用到。
2-1. 分段和分页都可以完成地址变换。其实现却不同。分页在分段之上。
    1. 分段机制提供了隔绝各个任务代码、数据和堆栈的机制。因此多个程序可以同时运行而互不影响。
    2. 分段机制将内存区域划分为成为段的受保护区域。可以用来存放代码，数据，堆栈，系统数据结构等信息。
    3. 每个程序都有自己个子的一套段。
    4. 段选择符存放在GDT表中。
    5. 段描述符指明了段的大小，访问权限，特权级别，段类型，段基地址。
    6. 段基地址+偏移量就可以得到一个线性地址。
2-2。 分页机制。多任务系统通常定义的线性地址空间要比其含有的物理内存容量要大得多。需要某种虚拟化手段，来增加虚拟内存空间的大小。
    1. 虚拟存储技术。联合硬盘的存储能力，扩充程序实际可以使用的内存大小。
    2. 分页机制支持虚拟存储技术。当使用分页机制的时候，每个段被分为页面（通常是4KB）。页面通常被保存在物理内存或者硬盘中。
    3. 操作系统通过维护一个页目录和页表来维护这些页面。将程序的线性地址转换为实际的物理地址。
    4. 当访问的页面不在内存中的时候，操作系统通过一个缺页异常，将对应页面加载入物理内存。
3. 保护。80x86提供了两种保护类型。
    1. 给每个不同的任务不同的虚拟地址映射来完全隔离任务。
    2. 保护操作系统内存段和和处理器特殊系统寄存器的值不被应用程序访问。
3-1。任务之间的保护。
    1. 为每个任务使用各自独立的段表和页表。
    2. 任务切换的关键就是切换到新任务的的段表和页表。
3-1 特权级别的保护。
    1. 在一个任务中，定义了4个特权级别。0具有最高级别，3则是最低特权。每个段都与一个特权级别关联。
    2. 程序从cs寄存器中指定的段内获取和执行指令。当前的特权级别成为CPL。
    3. 每当一个程序企图访问一个段的时候，就需要检验其特权级别。
    4. 每个特权级别都有其对应的堆栈。以避免共享共享栈带来的问题。当程序从一个特权级别切换到另一个特权级别的时候，堆栈段也需要切换到对应级别的堆栈段。
### 分段机制

#### 段的定义
段描述符
1. 段基地址。指定段在线性地址空间中开始的地址。
2. 段限长。段的最大可用偏移地址。
3. 段属性。特权级别，段类型等。
以上构成了段描述符。存储在内存中的段描述符表中。

将一个逻辑地址转换为线性地址的步骤：
1. 使用段选择符在GDT或者LDT中定位相应的段描述符。仅当一个新的段选择符加载到段寄存器中时才需要这一步。
2. 利用段描述符检验段的访问权限和范围。
3. 从段描述符中获得段基地址加上偏移量，形成线性地址。


段描述符表
段描述符表示段描述符的一个数组。描述符表的长度可变,最多可以包含8192个8字节描述符。有两种
1. 全局描述符表GDT（global descriptor table）
2. 局部描述符表LDT（local descriptor table）
当任务切换时，LDT会切换为新任务的LDT，而GDT不会切换。

段选择符
段选择符不直接指向段，而是指向段描述符表中的一个项目。
1. 请求特权级别RPL。
2. 表特权级别TL。0表示GDT，1表示LDT。
3. 索引值。

段描述符

代码段和数据段描述符

### 分页机制

分页机制是80x86内存管理的第二部分。它在分段机制的基础上完成虚拟地址到物理地址的转换工作。
1. CR0控制寄存器的PG位控制是否启用分页。
2. 页目录和页表一般放在TLB中。

#### 页表结构

页表存放在物理地址空间中。页表中的每个项目大小为32位，由于只需要20位来存储物理基地址，剩下的12位可以用来存放页面属性信息。

### 保护

## 中断和异常处理


## 任务管理

任务是处理器中可以被调度，执行，挂起的一个工作单元。

80x86提供了多任务的硬件支持。描述符表中于任务切换相关的的描述符有两类

1. 任务状态描述符。
2. 任务门。


任务的切换和过程调用很相似，但是需要保存更多的处理器信息。这种切换需要保存几乎当前所有的寄存器信息，包括标志寄存器和所有的段寄存器信息。处理器的所有信息都会被保存在一个称之为
任务状态段(TSS)的数据结构中。


#### 任务的结构和状态

任务由两部分组成：
1. 任务的执行空间。包括代码段，数据段和堆栈段。
2. 任务的状态段。指定了构成执行空间的各个段，并为任务的状态信息提供了存储空间。

一个任务由指向其TSS的段选择符来指定。当一个任务被加载到处理器中执行时，那么当前任务的段选择符，段限长，基地址以及TSS段描述符属性就会被加载道TR中。如果使用了分页机制，那么任务的页表基地址
就会被加载到CR3中。

#### 任务的执行

#### 任务管理数据结构

多任务相关的寄存器和数据结构

1. 任务状态段TSS。用于恢复一个任务的处理器状态信息被保存在一个称为任务状态段TSS的段中，段中包含了动态字段和静态字段。动态字段在任务切换时会由处理器更新器内容。静态字段包含了LDT，CR3，特权级别等信息。
2. TSS描述符。TSS段描述符只能存在GDT中。
3. 任务寄存器TR。存储了16位的段选择符和TSS描述符。
4. 任务门描述符。任务门可以存在LDT，IDT，GDT中。任务门中的TSS字段指向了GDT中的TSS描述符字段
5. 标志寄存器EFLAGS中的NT标志。

使用这些任务，处理器可以从一个任务切换到下一个任务，并保存原来任务的上下文。

#### 任务切换

处理器使用下列四种方式之一来进行任务切换：
1. 当前任务对GDT中的TSS字段执行Call或者jump指令
2. 当前任务对GDT或者LDT中的任务门描述符执行jmp或者call指令。
3. 中断或者异常向量指向IDT表中的任务门描述符。
4. 当EFLAGS的NT标志置位时当前任务执行IRET指令。
































































