---
title: linux0.11中的mount工作流程
tags: 
- linux
- 底层
- 文件系统
categories: 
- Linux 内核
---
date: 2019-11-22 09:47:00
---


### 概述

在linux0.11内核中，有全局的super_block数组(大小为8)和全局的inode数组(大小为32)。super block数组的大小为8，
以为着最多可以常驻8个文件系统的超级块，也就是说最多可以挂载8个不同的文件系统。inode数组的主要作用是为了缓存
最近使用的inode数据。

对于超级块和inode这里不做过多的介绍，相关的博客较多，不过，下面的图片是我在梳理流程的时候，根据源码绘制的，里面包含了超级块和inode的一些细节，以及在挂载过程中使用到的函数。

![](/images/mount.png)


### 关于缓冲头和缓冲区的介绍

在linux0.11版本的内核中，当内核从文件系统中读取到了指定块的数据之后，会将其缓冲在高速缓冲区中，而缓冲区头的作用就是标记其指向的缓冲区属于哪个设备的哪个数据块。

在我们挂载文件系统的过程中，必然涉及到了这些内容，所以这里实现提一下。

### 根目录的挂载流程

在linux内核启动的时候，必然要对根目录/进行挂载，其挂载流程如下：

1. 初始化超级块数组。同时初始化了文件数组（这个不是很理解）

2. 使用read_super函数读取根设备的超级块数据，并放置在超级块数组的第一项中

3. 使用iget函数读取根设备的第一个inode,并将其存放在inode数组的第一项中

4. 更新inode的引用计数，保证该inode不会被其他进程回收。

5. 将该super block的s_isup和s_imount为该inode，表示该superblock是根super_block并且其挂载点是该inode

6. 将启动进程的root工作更新为该inode，将启动进程的当前工作目录更新为该inode。

7. 打印一些与根目录元数据相关的信息

8. 挂载结束


### 其他文件系统的挂载分析

我们很容易可以推出其他文件系统的挂载流程，与根文件系统的挂载如出一辙，不同的是，被挂载文件系统super_block的s_isup不会被置位，表示其不是根文件系统


### 关于文件打开过程中的疑问

分析mount流程的动力在于，在我们去打开一个mount目录的文件的时候，内核中的执行流程如何对其进行判断，答案是置换。文件打开的流程分析：

1. 从根inode或者进程的当前工作目录inode开始，向下查找inode。
2. 当遇到一个挂载点inode(通过inode的i_mount属性判断)，内核在超级块数组中查找挂载在该inode的超级块，获取到超级块的dev设备号
3. 从对应设备号的设备读取第一个inode，替换为挂载点inode，就完成了mount点的转换。

当然，在上述过程中，遇到问题需要报错，遇到可以缓存的可以缓存，这里仅仅叙述了主要执行流程。
